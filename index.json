[{"content":"I\u0026rsquo;m a Computer Science student with a passion for everything quantitative. This site chronicals my interests, particularly problems and projects I\u0026rsquo;m working on.\nIf you have any questions about a post, ideas for what I should look at next, or just want to get to know me better, please get in touch!\n","date":"30 January 2025","externalUrl":null,"permalink":"/","section":"Barnaby's Blog","summary":"I\u0026rsquo;m a Computer Science student with a passion for everything quantitative.","title":"Barnaby's Blog","type":"page"},{"content":"","date":"30 January 2025","externalUrl":null,"permalink":"/tags/maths/","section":"Tags","summary":"","title":"Maths","type":"tags"},{"content":" The Lesson # It\u0026rsquo;s easy to get hooked on the idea of performance and optimisation, but when it comes to recurrence relation problems in programming, it\u0026rsquo;s easy to fall into the trap of chasing the perfect solution. You\u0026rsquo;ve done your homework, read up on all the maths, and now you\u0026rsquo;re ready to blast the next recurrence relation problem you see with algebra, find and utilise the closed form solution, and leave other\u0026rsquo;s code in the dust.\nThere\u0026rsquo;s only one problem: most of the time, it doesn\u0026rsquo;t work.\nFor starters, existing general purpose solutions like matrix exponentiation already work well: it\u0026rsquo;s simple to implement, applies to many recurrence problems and finds solutions in logarithmic time, and while I hate to admit it, in most situations that is fast enough.\nIndeed, most of the time you would actually care about improving speed beyond logarithmic time is when the inputs are really large, but this means that you are almost certainly taking the modulus of the answer, at least in any programming challenge, because most recurrence relations grow fast.\nTake for example the fibonacci sequence, the million\u0026rsquo;th term in the sequence has over 200,000 digits. These large numbers are awkward to deal with, so programming challenges ask for answers to be given to a modulus.\nThis use of modular arithmetic makes implementing closed form solutions much harder, because this solution will often involve real numbers instead of just integers, and the normal rules of modular arithmetic do not apply when using real numbers. You will see later in the problem I tried just how pesky these real numbers can be.\nHowever, there may still be those out there who would be undeterred by these barriers, who want to push on for greater performance even when it might not seem strictly necessary. Unfortunately, the real killer to the fervent optimser\u0026rsquo;s dream is the real-world performance of these solutions: often they actually perform worse than easier methods like matrix exponentiation.\nThis is partially because at the end of the day you\u0026rsquo;re doing exponentiation, either with scalars in the closed form or with matrices, meaning the extent to which you can improve the overall time complexity is limited. However, what can actually make the recurrent solution slower is the requirement for the real numbers in the closed form solution to be extremely accurate for large inputs, meaning finding and using these numbers can be extremely computationally expensive.\nYou will now see how I tried to solve a fairly standard recurrence relation problem using a more mathematical approach than is traditional, and how it failed.\nA Failed Attempt at getting Mathematical # The problem is one I have tackled before: Leetcode Problem 552. If you want more information about the problem and the solution using matrix exponentiation then please go read that article; the crux of the problem, if we want to use recurrence relations, is finding the following: $$ v(n) = \\sum_{i=0}^{n-1} F(i)F(n-i-1) $$ where \\(F(n)\\) is a Tribonacci number: $$ F(n)=F(n-1)+F(n-2)+F(n-3) $$\nMathematical Solution # Calculating F(n) # First, I found the roots of the characteristic equation: $$ x^3-x^2-x-1=0 $$\nI then used sympy to find the roots and coefficients of the closed form solution: $$ F(n) = A r_1^n + B r_2^n + C r_3^n $$\nHere are the numerical approximations to these values:\n\\(A \\approx 1.137 \\) \\(r_1 \\approx 1.839 \\) \\(B \\approx -0.0687 + 0.124 i \\) \\(r_2 \\approx -0.420 + 0.606 i\\) \\(C \\approx -0.0687 - 0.124 i\\) \\(r_3 \\approx -0.420 - 0.606 i\\) The exact roots and coefficients are complicated, but what is important about these values are:\nthey aren\u0026rsquo;t rational two of the terms in our function are complex the two complex terms are very small and get smaller as n grows when combined they make an integer (since \\(F(n)\\) is an integer) The small size of the two complex terms are very helpful, because they are small enough that we can simply ignore them and round the first term: $$ F(n) \\approx A r_1^n $$\nCalculating v(n) # Remember we have the following formula for \\(v(n)\\): $$ v(n) = \\sum_{i=0}^{n-1} F(i)F(n-i-1) $$\nIf we now sub in our formula for \\(F(n)\\)\n$$ v(n) = \\sum_{i=0}^{n-1} (Ar_1^i+Br_2^i+Cr_3^i)(Ar_1^{n-i-1}+Br_2^{n-i-1}+Cr_3^{n-i-1}) $$\nWe only need to consider terms involving \\(Ar_1^n\\) in our approximation: $$ v(n) \\approx \\sum_{i=0}^{n-1} A^2r_1^{n-1} + Ar_1^i(Br_2^{n-i-1}+Cr_3^{n-i-1}) + Ar_1^{n-i-1}(Br_2^i+Cr_3^i) $$\nThe sum of terms 2 and 3 are the same: $$ v(n) \\approx \\sum_{i=0}^{n-1} A^2r_1^{n-1} + 2Ar_1^i(Br_2^{n-i-1} + Cr_3^{n-i-1}) $$\nWe can use the following formula to help us evaluate the 2nd term: $$ \\sum_{i=0}^n a^i b^{n-i} = \\frac{b^{n+1}-a^{n+1}}{b-a} $$\nIn this case, due to the size of the complex terms growing insignificant when raised to the power of n, we can ignore the \\(a^{n+1}\\) part for those terms: $$ v(n) \\approx nA^2r_1^{n-1} + 2A(B \\frac{r_1^n}{r_1-r_2} + C \\frac{r_1^n}{r_1-r_3}) $$\nWe are only interested in the real part of the sum, and we know that the answer we are approximating is real, so we can safely remove the imaginary part (it would have been cancelled out by the other complex terms if we hadn\u0026rsquo;t ignored them). The real part is the same for both terms in the brackets, so we can just take the real part of one and multiply by two: $$ v(n) \\approx nA^2r_1^{n-1} + 4Ar_1^n \\cdot \\Re(\\frac{B}{r_1-r_2}) $$\nFinal formula # The actual solution requires adding \\(F(n)\\) to \\(v(n)\\) and taking the modulus: $$ \\text{solution} = \\text{round}(Ar_1^{n-1}[nA+4r_1 \\cdot \\Re(\\frac{B}{r_1-r_2})+r_1]) \\mod m $$\nThis formula looks a little complicated, but there are only two parts of the formula that involve n. Therefore we can simply the formula to: $$ \\text{solution} = \\text{round}(r_1^{n-1}[A^2 n + c]) \\mod m $$\nNote that while the \u0026lsquo;round\u0026rsquo; function may look a little messy, it only accounts for the complex terms in the closed form solution that we ignored, which get very small quickly, so even without the round function the answer would be very close, especially for larger n.\nImplementing the solution # This is the point where maths meets reality. At this point a mathematician would have sat back and enjoyed their formula that gives the answer for any n neatly.\nHowever, this is very difficult to implement in a program due to the fact that \\(r_1\\) is a real number, and so are the other terms \\(A^2 n + c\\), which stops us from being able to do any useful modular arithmetic tricks.\nLet\u0026rsquo;s explore some of the ideas I tried to use modular arithmetic to get a fast solution.\nmodular exponentiation # Normally, you would see \\(r^n \\mod m\\) and think of using the multiplicative order of r: $$ r^k = 1 \\mod m $$ $$ r^n = r^{n \\ \\% \\ k} \\mod m $$\nUnfortunately, this does not hold when using real numbers. For example:\nlet \\(k = \\log_{1.8}(8)\\) so \\(1.8^k = 1 \\mod 7\\) \\(1.8^{10} \\approx 0.05 \\mod 7 \\) \\(1.8^{10 \\ \\% \\ k} \\approx 5.8 \\mod 7\\) mixed approach with matrices # OK, so at this point I thought fine, if I can\u0026rsquo;t find \\(r_1^{n-1} % m\\) using my closed form solution, I can just find the related value \\(F(n-1)\\) using matrix exponentiation, and then multiply by \\(A^2 n + c\\).\nThis should still be faster than finding the answer directly with matrix exponentiation since to find the solution directly using that technique requires a 7x7 matrix (in my solution), while to just find \\(F(n)\\) only requires a 3x3 matrix. Since matrix multiplication is \\(O(n^3)\\), this should result in roughly a 12x speed increase.\nUnfortunately, once again the rules of modular arithmetic thwart us. In particular, while the following property holds for integers, it is not true for real numbers: $$ ab \\mod m \\ne ((a \\mod m) \\cdot (b \\mod m)) \\mod m $$\nThis means that even if we use matrix exponentiation to calculate \\( r_1^{n-1}\\) mod m, we cannot multiply it by our constant to get the answer mod m.\nNo modular tricks # So we can\u0026rsquo;t use any modular tricks, so what? We can still use our formula to calculate the final value and then just mod that.\nThis approach works and can be easily implemented:\ndef solve_with_recurrence(n, A, B, r1, r2): if n == 1: return 3 elif n == 2: return 8 c = A*(4*r1*sympy.re(B/(r1-r2)) + r1) return round(r1**(n-1) * (A*A*n+c)) % 1000000007 Analysing my solution # However, what\u0026rsquo;s being hidden in the previous code snippet is the calculation of the constants passed to the function, as well as exactly what they look like. The problem is that since our answer could be thousands of digits long, so do our floats. Doing calculations with these large floats is computationally expensive, but what is even more computationally expensive is calculating them in the first place.\ndef get_constants(precision): # get precomputed exact representations of the values with open(\u0026#34;sympy_expr.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: stored_expr = sp.sympify(f.read()) return [term.evalf(precision) for term in stored_expr] timeit.timeit(lambda: get_constants(digits_precision), number=5)/5 digits precision time 1,000 0.09s 5,000 1.34s 10,000 4.6s 20,000 16s 100,000 5m 15s It takes a long time to compute these values, seemingly exhibiting a time complexity of ~\\(O(n^2)\\), but surely with thousands of places of precision we should be able to calculate solutions for massive n? Well, I found through experimentation that in order to maintain accuracy, you need roughly \\(\\frac{n}{3}\\) places of decimal precision to calculate the solution for n. This means that this method quickly becomes infeasible for large n.\nHowever, let\u0026rsquo;s say we can precompute these values to a large precision on our supercomputer, we are then guaranteed our function will work up to a certain n and any normal computer can compute solutions blazingly fast; it won\u0026rsquo;t fix the fact that our program now has a linear space complexity but as long as it\u0026rsquo;s fast, it\u0026rsquo;s fine. Let\u0026rsquo;s take a look at how our solution using the closed form solution stacks up against the default matrix exponentiation solution:\nA,B,r1,r2 = get_constants(n//3) recurrence_time = timeit(lambda: solve_with_recurrence(n,A,B,r1,r2), number=1000)/1000 matrix_time = timeit(lambda: solve_with_matrix(n), number=1000)/1000 n matrix time recurrence time 50,000 \u0026lt;0.1ms 5ms 100,000 \u0026lt;0.1ms 11ms 300,000 0.1ms 75ms \\(10^{61}\\) 1ms ? It turns out the function, even with precomputed values, is actually much slower than the matrix exponent method due to the precision of the floats and the size of the intermediate numbers being calculated, since we cannot make use of any modular arithmetic tricks. In fact, due to the precision of the floats growing linearly, the new function displays a completely different (worse) time complexity.\nConclusion # There\u0026rsquo;s a lot of smart engineers and mathematicians out there that can probably improve on my attempts using the closed form solution to the recurrence and leverage its power to some extent.\nHowever, I\u0026rsquo;d prefer to not have to be smart. If nothing else from my little journey, please take away the fact that you can spend a significant amount of time playing around with the maths and code to try and find a way to make your fancy mathematical method work, all for it to be no faster than what you could have done in 10 minutes.\nSometimes it pays to try and be clever, but other times it\u0026rsquo;s best to just use what\u0026rsquo;s well established. Sure, go ahead and check what the closed form solution is, but if you see irrational complex numbers, I\u0026rsquo;d recommend spending your time optimising another problem.\n","date":"30 January 2025","externalUrl":null,"permalink":"/problems/recurrence_relations_in_programming/","section":"Problems","summary":"The Lesson # It\u0026rsquo;s easy to get hooked on the idea of performance and optimisation, but when it comes to recurrence relation problems in programming, it\u0026rsquo;s easy to fall into the trap of chasing the perfect solution.","title":"Pragmatic Recurrence Relations: Why the Closed Form Won't Help You","type":"problems"},{"content":"This section contains all my articles on Maths and Algorithms problems.\n","date":"30 January 2025","externalUrl":null,"permalink":"/problems/","section":"Problems","summary":"This section contains all my articles on Maths and Algorithms problems.","title":"Problems","type":"problems"},{"content":"","date":"30 January 2025","externalUrl":null,"permalink":"/tags/recurrence-relation/","section":"Tags","summary":"","title":"Recurrence Relation","type":"tags"},{"content":"","date":"30 January 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Problem Description # Two random points, one red and one blue, are chosen uniformly and independently from the interior of a square. To ten decimal places, what is the probability that there exists a point on the side of the square closest to the blue point that is equidistant to both the blue point and the red point?\nYou can check out the problem on their website, however if you want to check their solution be aware that as of writing there is a mistake in their proposed integral, so please refer to the one I have provided. I have made them aware of this issue.\nSolution # Mathematical representation of the problem # For this problem, we need to consider which parts of the selected wall are closest to blue, closest to red, and an equal distance.\nLet\u0026rsquo;s plot some examples, highlighting the part of the relevant side which is closest to red or blue:\nAs seen above, for any two points, there are two possibilites:\none point is closest to the whole side each point has a share of the side If one point is closest to the whole side, then there cannot be a point on that side which is equidistant from both. However, in the 2nd case, there must be a point on the side equidistant of the two, located where the two highlighted areas meet.\nTo check these cases, we check the two corners. If the closest point to each corner is the same, then that point is closest to the whole side, but if one corner is closest to blue and the other closest to red, then each point has a share of the side and there will be a solution.\nLet\u0026rsquo;s fix the blue point, and consider its distance from each corner:\nThe red point needs to closer to one corner, and not the other. We can find the boundary for being closer to a corner by drawing a circle from it:\nTo get a solution the red point must be inside one circle, but not both:\nRecap # We have found an alternative way to represent the original problem as the probability of the red point being in the highlighted red area. From now on we will define the total area of the square to be 1, so if the red area is 0.63 then the probability of there being a valid solution is 63%.\nThe question asks about the average probability across all possible blue point positions, so the answer to the question is the average red area.\nCreating an equation to solve # simplifying the representation # Due to the symmetry of the square, we can choose to view the blue point from the perspective where its closest side is along the x-axis, and its closest corner is along the y axis.\n(cyan = possible place for the blue point)\nProbability for a single blue position # To find the area, we can add the areas of the individual quarter-circles, and then subtract their intersection twice (one time to account for double counting, and the second to actually remove the area from the valid space).\nLet \\(r_c,r_f\\) be the distance from the blue point to the closest and furthest corner of its side respectively.\nLet \\(p(x,y)\\) be the probability of a valid solution given the blue point is at position \\((x,y)\\).\n$$ p(x,y) = \\frac{\\pi}{4}(r_c^2+r_f^2) - 2*\\text{intersection} $$\nTo find the area of intersection, we add together the segments from each circle that makes it, and subtract the total area formed by the triangle between the two corners and \\((x,y)\\). $$ \\text{intersection} = \\frac{\\alpha}{2 \\pi} \\pi r_c^2 + \\frac{\\beta}{2 \\pi} \\pi r_f^2 - \\frac{y}{2} $$\nwhere $$ \\alpha = \\arctan(\\frac{y}{x}) $$ $$ \\beta = \\arctan(\\frac{y}{1-x}) $$ $$ r_c = \\sqrt{x^2+y^2} $$ $$ r_f = \\sqrt{(1-x)^2+y^2} $$\nmean probability for all blue positions # To get the average of our probability function for all blue points, we integrate over all blue points and divide by the area of the bounds.\nThe bounds on the blue point\u0026rsquo;s position are represented by the cyan triangle seen earlier. This triangle has a slope that follows the gradient \\(y=x\\), so we represent the triangle using the following inequalities: $$ 0 \\le y \\le x $$ $$ 0 \\le x \\le 0.5 $$\nThe area of these bounds is \\(\\frac{1}{8}\\), so the mean probability (and the answer to the question) is given by: $$ 8\\int_{0}^{\\frac{1}{2}} \\int_{0}^{x} p(x,y) \\ dx \\ dy $$\nSolving the equation # Given that we don\u0026rsquo;t need to find the exact solution to the problem, we can use numerical methods to approximate the integral:\nfrom scipy.integrate import dblquad from math import atan, pi def p(y,x): if x==0 or y==0: return 0 r1_sq = x**2 + y**2 r2_sq = (1-x)**2 + y**2 area = pi / 4 * (r1_sq+r2_sq) intersection = 1/2*atan(y/x)*r1_sq + 1/2*atan(y/(1-x))*r2_sq - y/2 return area - 2*intersection integral_val= dblquad(p, 0.0, 0.5, lambda x: 0.0, lambda x: x)[0] result = integral_val*8 This outputs 0.49140757883830793\nHowever, we can do better! Using python\u0026rsquo;s sympy library, we can calculate the exact result of the integral:\nimport sympy as sp x,y = sp.symbols(\u0026#39;x y\u0026#39;) r1_sq = x**2 + y**2 r2_sq = (1-x)**2 + y**2 area = sp.pi / 4 * (r1_sq+r2_sq) intersection = sp.Rational(1,2)*(sp.atan(y/x)*r1_sq + sp.atan(y/(1-x))*r2_sq - y) integrand = area - 2*intersection integral_val = sp.integrate(integrand, (y,0,x), (x,0,sp.Rational(1,2)) result = integral_val*8 This outputs -17*log(2)/6 + 1/12 + pi/6 + 4*log(4)/3\nWe can simplify this further:\nsimplified_log = sp.simplify(-17 * sp.log(2) / 6 + 4*sp.log(4)/3) # -log(2)/6 Therefore the final answer is: $$ \\frac{1+2\\pi - \\ln(4)}{12} $$\nBonus: An easy mistake when using sympy # When I first wrote the previous code, I used 0.5 instead of sp.Rational(1,2) as the bound for the integral:\nintegral_val = sp.integrate(integrand, (y,0,x), (x,0,0.5)) This is a mistake because it prevented sympy from giving an exact answer, however it still tried, leading to a potentially misleading output that mixes exact terms with numerical approximations.\nresult # -2*log(2)/3 + 0.125*pi + 0.560806617512881 However, you can still use evaluate the output to get the correct numerical approximation:\nresult.evalf()*8 # 0.491407578838308 ","date":"22 January 2025","externalUrl":null,"permalink":"/problems/jane_street_and_numerical_integration/","section":"Problems","summary":"Problem Description # Two random points, one red and one blue, are chosen uniformly and independently from the interior of a square.","title":"Jane Street Puzzle: Beside The Point","type":"problems"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":" Problem Description # Check out the problem on Leetcode\nGiven a non-negative integer \\(c\\), decide whether there exists two integers \\(a\\) and \\(b\\) such that \\(a^2+b^2=c\\)\nSolution # Try different combinations of \\((a,b)\\), adjusting the guess each time based on whether their sum is too large or too small. I define \\(a\\) as the smaller value and \\(b\\) as the larger value.\nInitial values # \\(a=0\\) \\(b^2\u0026gt;=c\\) \\(\\text{sum}=b^2\\) Finding the solution # If the sum is too big, then make \\(b\\) smaller. If it is too large, make \\(a\\) larger. Stop when \\(a\u0026gt;b\\).\nOptimising sum calculation # \\((a+1)^2 = a^2+2a+1\\)\n\\((b-1)^2 = b^2-2b+1\\)\nWe can use this to update sum:\n\\((a+1)^2+b^2 = a^2+2a+1+b^2\\)\n\\( \\quad \\quad \\quad \\quad \\quad \\ \\ \\ = \\text{sum} + 2a + 1\\)\nTherefore, instead of recalculating the sum each time using a*a+b*b, we can instead use these formulae. For example, if increasing a, sum += 2a+1.\nComplexity # Time complexity: O(\\(\\sqrt{n}\\) )\nSpace complexity: O(1)\nCode # bool judgeSquareSum(const int\u0026amp; c) { // let a\u0026lt;=b unsigned int a = 0; unsigned int b = ceil(sqrt(c)); unsigned int sum = b*b; while(a\u0026lt;=b){ if(sum==c){ return true; } else if(sum\u0026lt;c){ // increase a // (a+1)^2 = a^2 +2a+1 sum += 2*a+1; a++; } else{ // decrease b // (b-1)^2 = b^2-2b+1 sum += 1-2*b; b--; } } return false; } ","date":"17 June 2024","externalUrl":null,"permalink":"/problems/leetcode_633/","section":"Problems","summary":"Problem Description # Check out the problem on Leetcode","title":"Leetcode 633: Sum of Square Numbers","type":"problems"},{"content":" Problem Description # Check out the problem on Leetcode\nYou have a string representing the attendance record of a student:\nA = Absent L = Late P = Present You must find the number of strings of length n that have the following properties:\nonly contain the letters (A,L,P) contain less than two A\u0026rsquo;s don\u0026rsquo;t contain any occurences of \u0026lsquo;LLL\u0026rsquo; Solution 1 - Using Recurrences # This approach will be to use recurrence relations to calculate the number of combinations whilst avoiding considering the actual possible strings.\nCreating a recurrence (ignoring absences) # Let \\(S_n\\) be a valid string with no absences. Let \\(F(n)\\) be the number of such strings. We can make a valid string \\(S_n\\) using shorter ones:\n\\(S_{n-1}\\) + P \\(S_{n-2}\\) + PL \\(S_{n-3}\\) + PLL We can get all possible strings (longer than 3) this way with no double counting. For example, PLLPPL = PLL + P + PL.\nTherefore: \\(F(n)=F(n-1)+F(n-2)+F(n-3)\\)\nAccounting for absences # We are allowed to have a maximum of one absence.\nIf the absence is after lesson \\(i\\), then we have a no-absence string of length \\(i\\) before it and a no-absence string of length \\(n-i-1\\) after it. For example, if we have 10 lessons and the student is absent for lesson 3:\n$$ \\text{string} = S_2 + A + S_7 $$\nTherefore, the number of valid strings for a given absence = \\(F(i) * F(n-i-1)\\)\nWe can find the total number of valid strings by iterating over all possible lessons up to \\(i=n/2\\) and then multiply by two because \\(F(2)*F(7) = F(7)*F(2)\\).\nFinally, we add \\(F(n)\\) to the total, for the situation where the student has no absences.\nComplexity # Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) Code # int checkRecord(const int\u0026amp; n) { // check for base case if(n==1){ return 3; } else if(n==2){ return 8; } // F[n] = number of ways to form a string of length n with no absences vector\u0026lt;long long\u0026gt; F(n+1, 0ll); F[0]=1; F[1]=2; F[2]=4; const long long MOD = 1000000007; for(int i=3; i\u0026lt;=n; i++){ F[i] = (F[i-3]+F[i-2]+F[i-1]) % MOD; } long long numWithAbsences = 0; for(int i=0; i\u0026lt;n/2; i++){ numWithAbsences += (F[i]*F[n-i-1]) % MOD; } numWithAbsences *= 2; if(n % 2 == 1){ numWithAbsences += F[n/2]*F[n/2]; } return (F[n] + numWithAbsences) % MOD; } Solution 2 - Matrix Exponentiation # Often in questions where you have a limited number of states you can be in, and you\u0026rsquo;re trying to find the total number of ways to generate some sequence of these, you can represent this using a transition matrix.\nThe \u0026lsquo;state\u0026rsquo; of our string in this case depends on the last letters and whether the student has been absent before. In our transition matrix, we will put a \\(1\\) in position \\((x,y)\\) if we can move from state \\(x\\) to state \\(y\\). We will represent a state where we have already been absent using \\(x^A\\).\nGraphic by user5382x on Leetcode To understand this matrix, lets look at row \\(L^A\\). This means the last letter is \\(L\\) and the student has been absent before. Therefore, the next day can either be another late day, in which case we move to state \\({LL}^A\\), or the student is present, in which case we move to \\(P^A\\). No other states are possible, so the rest of the row values are 0.\nusing the matrix # This matrix represents all the possible letters you can add in one day, depending on your state. If we want to find the number of strings we can add in \\(n\\) days, then we can just multiply \\(n\\) of these matrices together (add one letter, then another, then another\u0026hellip;)\nWe can find the exponent of the matrix in \\(O(\\log n)\\)using exponentiation by squaring. Essentially, we keep squaring the matrix \\(M\\) so we get \\([M, M^2, M^4, M^8, M^{16} \\dots ]\\). Since this question uses modular arithmetic, we will find these values mod m.\nWe multiply values in the list together to get our exact exponent. For example, if we wanted to find \\(M^{13}\\), we would use \\(M^8 \\cdot M^4 \\cdot M\\).\nOnce we have our final transition matrix, we want to sum together all the different paths that start with the possible starting states. The mathematical way to write this is to first get the dot product of our starting states [1,1,1,0,0,0,0] (since we must start with an A,P or L) with our final transition matrix, which will tell us how many ways there are to get to each final state.\nFor example, if we calculate the dot product of our starting states with \\(M^5\\), we get [13,13,7,4,30,19,8], which means that there are 19 ways of reaching the state \\(L^A\\).\nTherefore, to get the total number of paths to any final state, we take the sum of these numbers.\nCode # I used numpy to calculate the matrix operations efficiently.\ndef solve_with_matrix(n): base = np.array([ [0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0] ], dtype=np.int64) final_transition_matrix = np.eye(7, dtype=np.int64) MOD = 10**9+7 n = n-1 while(n\u0026gt;0): if(n%2==1): final_transition_matrix = np.dot(final_transition_matrix, base)%MOD base = np.dot(base, base) % MOD n //= 2 start = np.array([1,1,1,0,0,0,0], dtype=np.int64) return np.dot(start, final_transition_matrix).sum() % MOD Complexity # Time Complexity: \\(O(\\log n)\\) Space Complexity: \\(O(1)\\) ","date":"26 May 2024","externalUrl":null,"permalink":"/problems/leetcode_552/","section":"Problems","summary":"Problem Description # Check out the problem on Leetcode","title":"Leetcode 552: Student Attendance Record II","type":"problems"},{"content":" Problem Description # Check out the full problem description\nThere are two types of people:\nThe good person: The person who always tells the truth. The bad person: The person who might tell the truth and might lie. You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following:\n0 which represents a statement made by person i that person j is a bad person. 1 which represents a statement made by person i that person j is a good person. 2 represents that no statement is made by person i about person j. Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 \u0026lt;= i \u0026lt; n.\nReturn the maximum number of people who can be good based on the statements made by the n people.\nSolution # The general approach I will take is to iterate over each possible configuration of good and bad people using bit manipulation.\nRepresenting a configuration # Represent a possible configuration of n people using n bits.\n1 = good person 0 = bad person E.g. 1010 = People 1,3 are good. People 2,4 are bad.\nIterating over configurations # Naive approach # We can iterate over all the possible configurations, starting with all people lying, like so:\nfor(int config=0; config\u0026lt;(1\u0026lt;\u0026lt;n); config++){ // check if the solution is valid } Improved approach # We first start by looking at configurations where everyone is good. We then stop looking when none of the remaining possible solutions can beat our current one.\nFor example, imagine we have five people, and found a configuration where 3 could be telling the truth (maxGood is 3), we need to find at least four 1\u0026rsquo;s (truthful bits) to find a better solution. In this example, if config\u0026lt;01111, then we can stop because config is decreasing, so it will never have four 1\u0026rsquo;s.\ninitialise config = 111...1111 stop searching when config \u0026lt; ..000111.. (ending in maxGood 1\u0026rsquo;s) for(int config=(1\u0026lt;\u0026lt;n)-1; config \u0026gt;= (1\u0026lt;\u0026lt;(maxGood+1))-1; config--){ // check if the solution is valid } Checking if a solution is valid # A solution is invalid when someone who is assumed to be truthful tells a lie. (Ignore what the liars say.)\nTherefore, iterate over all the truthful people in a solution and check what they say matches our proposed solution.\nbool configurationWorks = true; // iterate over each person in the config for(int j=0; j\u0026lt;n \u0026amp;\u0026amp; configurationWorks; j++){ if((config\u0026gt;\u0026gt;j)\u0026amp;1){ // the current person is telling the truth for(int h=0; h\u0026lt;n; h++){ // the accused is not what they are supposed to be // e.g. person j says person h is good when they are bad if(statements[j][h] != 2 \u0026amp;\u0026amp; statements[j][h] != ((config\u0026gt;\u0026gt;h)\u0026amp;1)){ configurationWorks = false; break; } } } } Setting the new Max Score # The number of good people in a configuration is the number of 1\u0026rsquo;s in the binary representation of config. There is already a function to do this called __builtin_popcount.\nif(configurationWorks){ maxGood = max(maxGood, __builtin_popcount(config)); } Complexity # Time complexity: O(\\(N^2 * 2^N\\))\nSpace complexity: O(\\(\\sqrt{N}\\))\nCode # class Solution { public: int maximumGood(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; statements) { int n = statements.size(); int maxGood = 0; // config has n bits. A 1 represents good, and a 0 represents bad for(int config=(1\u0026lt;\u0026lt;n)-1; config \u0026gt;= (1\u0026lt;\u0026lt;(maxGood+1))-1; config--){ bool configurationWorks = true; // iterate over each person in the config for(int j=0; j\u0026lt;n \u0026amp;\u0026amp; configurationWorks; j++){ if((config\u0026gt;\u0026gt;j)\u0026amp;1){ // the current person is telling the truth for(int h=0; h\u0026lt;n; h++){ // the accused is not what they are supposed to be // e.g. person j says person h is good when they are bad if(statements[j][h] != 2 \u0026amp;\u0026amp; statements[j][h] != ((config\u0026gt;\u0026gt;h)\u0026amp;1)){ configurationWorks = false; break; } } } } if(configurationWorks){ maxGood = max(maxGood, __builtin_popcount(config)); } } return maxGood; } }; ","date":"24 May 2024","externalUrl":null,"permalink":"/problems/leetcode_2151/","section":"Problems","summary":"Problem Description # Check out the full problem description","title":"Leetcode 2151: Maximum Good People Based on Statements","type":"problems"},{"content":" Problem Description # The Problem:\nGiven an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.\nExample:\nInput: nums = [-1, 10, 6, 7, -7, 1] Output: 7 Explanation: Both 1 and 7 have their corresponding negative numbers in the array. 7 is the largest. Solution Approach # General Approach # Pass over the array, storing the fact we have seen that item. If the number\u0026rsquo;s negative has been seen before, then update the new maximum value.\nOptimisations # The constraints only allow a small range of possible values:\n\\( -1000 \u0026lt;= \\text{nums[i]} \u0026lt;= 1000\\)\nTherefore, we can use a static data structure, like an array, and store for every possible number whether we have seen it.\nSince we only need to store true/false for each number to represent whether it has been seen before, we can use a bitset for space efficiency.\nGiven the smallest possible value is -1000, this will be index 0, and so to get the index of a number you add 1000.\nExample # we see the number 47 seen[1000-47]==1 is checked and found false so seen[1047] is set to 1 Later, the number -47 is seen. seen[1000 -(-47)]==1 is checked and found true |-47| is compared to the current maximum number Complexity # Time complexity: O(n)\nSpace complexity: O(n)\nCode # class Solution { public: int findMaxK(const vector\u0026lt;int\u0026gt;\u0026amp; nums) { // indexes 1001-2000 represent positives. 0-999 are negatives bitset\u0026lt;2001\u0026gt; nums_bitset; int ans = -1; for(const int\u0026amp; num : nums){ if(nums_bitset[1000-num]==1){ ans = max(ans, abs(num)); } else{ nums_bitset[1000+num] = 1; } } return ans; } }; ","date":"2 May 2024","externalUrl":null,"permalink":"/problems/leetcode_2441/","section":"Problems","summary":"Problem Description # The Problem:","title":"Leetcode 2441. Largest Positive Integer That Exists With Its Negative","type":"problems"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]