[{"content":" Problem Description # Two random points, one red and one blue, are chosen uniformly and independently from the interior of a square. To ten decimal places, what is the probability that there exists a point on the side of the square closest to the blue point that is equidistant to both the blue point and the red point?\nYou can check out the problem on their website, however if you want to check their solution be aware that as of writing there is a mistake in their proposed integral, so please refer to the one I have provided. I have made them aware of this issue.\nSolution # Mathematical representation of the problem # For this problem, we need to consider which parts of the selected wall are closest to blue, closest to red, and an equal distance.\nLet\u0026rsquo;s plot some examples, highlighting the part of the relevant side which is closest to red or blue:\nAs seen above, for any two points, there are two possibilites:\none point is closest to the whole side each point has a share of the side If one point is closest to the whole side, then there cannot be a point on that side which is equidistant from both. However, in the 2nd case, there must be a point on the side equidistant of the two, located where the two highlighted areas meet.\nTo check these cases, we check the two corners. If the closest point to each corner is the same, then that point is closest to the whole side, but if one corner is closest to blue and the other closest to red, then each point has a share of the side and there will be a solution.\nLet\u0026rsquo;s fix the blue point, and consider its distance from each corner:\nThe red point needs to closer to one corner, and not the other. We can find the boundary for being closer to a corner by drawing a circle from it:\nTo get a solution the red point must be inside one circle, but not both:\nRecap # We have found an alternative way to represent the original problem as the probability of the red point being in the highlighted red area. From now on we will define the total area of the square to be 1, so if the red area is 0.63 then the probability of there being a valid solution is 63%.\nThe question asks about the average probability across all possible blue point positions, so the answer to the question is the average red area.\nCreating an equation to solve # simplifying the representation # Due to the symmetry of the square, we can choose to view the blue point from the perspective where its closest side is along the x-axis, and its closest corner is along the y axis.\n(cyan = possible place for the blue point)\nProbability for a single blue position # To find the area, we can add the areas of the individual quarter-circles, and then subtract their intersection twice (one time to account for double counting, and the second to actually remove the area from the valid space).\nLet \\(r_c,r_f\\) be the distance from the blue point to the closest and furthest corner of its side respectively.\nLet \\(p(x,y)\\) be the probability of a valid solution given the blue point is at position (x,y).\n$$ p(x,y) = \\frac{\\pi}{4}(r_c^2+r_f^2) - 2*\\text{intersection} $$\nTo find the area of intersection, we add together the segments from each circle that makes it, and subtract the total area formed by the triangle between the two corners and \\((x,y)\\). $$ \\text{intersection} = \\frac{\\alpha}{2 \\pi} \\pi r_c^2 + \\frac{\\beta}{2 \\pi} \\pi r_f^2 - \\frac{y}{2} $$\nwhere $$ \\alpha = \\arctan(\\frac{y}{x}) $$ $$ \\beta = \\arctan(\\frac{y}{1-x}) $$ $$ r_c = \\sqrt{x^2+y^2} $$ $$ r_f = \\sqrt{(1-x)^2+y^2} $$\nmean probability for all blue positions # To get the average of our probability function for all blue points, we integrate over all blue points and divide by the area of the bounds.\nThe bounds on the blue point\u0026rsquo;s position are represented by the cyan triangle. This triangle has a slope that follows the gradient \\(y=x\\), so we represent the triangle using the following inequalities: $$ 0 \\le y \\le x $$ $$ 0 \\le x \\le 0.5 $$\nThe area of these bounds is \\(\\frac{1}{8}\\), so the mean probability (and the answer to the question) is given by: $$ 8\\int_{0}^{\\frac{1}{2}} \\int_{0}^{x} p(x,y) \\ dx \\ dy $$\nSolving the equation # Given that we don\u0026rsquo;t need to find the exact solution to the problem, we can use numerical methods to approximate the integral:\nfrom scipy.integrate import dblquad from math import atan, pi def p(y,x): if x==0 or y==0: return 0 r1_sq = x**2 + y**2 r2_sq = (1-x)**2 + y**2 area = pi / 4 * (r1_sq+r2_sq) intersection = 1/2*atan(y/x)*r1_sq + 1/2*atan(y/(1-x))*r2_sq - y/2 return area - 2*intersection integral_val= dblquad(p, 0.0, 0.5, lambda x: 0.0, lambda x: x)[0] result = integral_val*8 This outputs 0.49140757883830793\nHowever, we can do better! Using python\u0026rsquo;s sympy library, we can calculate the exact result of the integral:\nimport sympy as sp x,y = sp.symbols(\u0026#39;x y\u0026#39;) r1_sq = x**2 + y**2 r2_sq = (1-x)**2 + y**2 area = sp.pi / 4 * (r1_sq+r2_sq) intersection = sp.Rational(1,2)*(sp.atan(y/x)*r1_sq + sp.atan(y/(1-x))*r2_sq - y) integrand = area - 2*intersection integral_val = sp.integrate(integrand, (y,0,x), (x,0,sp.Rational(1,2)) result = integral_val*8 This outputs -17*log(2)/6 + 1/12 + pi/6 + 4*log(4)/3\nWe can simplify this further:\nsimplified_log = sp.simplify(-17 * sp.log(2) / 6 + 4*sp.log(4)/3) # -log(2)/6 Therefore the final answer is: $$ \\frac{1+2\\pi - \\ln(4)}{12} $$\nBonus: An easy mistake when using sympy # When I first wrote the previous code, I used 0.5 instead of sp.Rational(1,2) as the bound for the integral:\nintegral_val = sp.integrate(integrand, (y,0,x), (x,0,0.5)) This is a mistake because it prevented sympy from giving an exact answer, however it still tried, leading to a potentially misleading output that mixes exact terms with numerical approximations.\nresult # -2*log(2)/3 + 0.125*pi + 0.560806617512881 However, you can still use evaluate the output to get the correct numerical approximation:\nresult.evalf()*8 # 0.491407578838308 ","date":"22 January 2025","externalUrl":null,"permalink":"/problems/jane_street_and_numerical_integration/","section":"Problems","summary":"Problem Description # Two random points, one red and one blue, are chosen uniformly and independently from the interior of a square.","title":"Jane Street Puzzle: Beside The Point","type":"problems"},{"content":"","date":"22 January 2025","externalUrl":null,"permalink":"/tags/maths/","section":"Tags","summary":"","title":"Maths","type":"tags"},{"content":"I\u0026rsquo;m a Computer Science student with a passion for everything quantitative. This site chronicals my interests, particularly problems and projects I\u0026rsquo;m working on.\nIf you have any questions about a post, ideas for what I should look at next, or just want to get to know me better, please get in touch!\n","date":"22 January 2025","externalUrl":null,"permalink":"/","section":"My Homepage","summary":"I\u0026rsquo;m a Computer Science student with a passion for everything quantitative.","title":"My Homepage","type":"page"},{"content":"This section contains all my articles on Maths and Algorithms problems.\n","date":"22 January 2025","externalUrl":null,"permalink":"/problems/","section":"Problems","summary":"This section contains all my articles on Maths and Algorithms problems.","title":"Problems","type":"problems"},{"content":"","date":"22 January 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":" Problem Description # Check out the problem on Leetcode\nGiven a non-negative integer \\(c\\), decide whether there exists two integers \\(a\\) and \\(b\\) such that \\(a^2+b^2=c\\)\nSolution # Try different combinations of \\((a,b)\\), adjusting the guess each time based on whether their sum is too large or too small. I define \\(a\\) as the smaller value and \\(b\\) as the larger value.\nInitial values # \\(a=0\\) \\(b^2\u0026gt;=c\\) \\(\\text{sum}=b^2\\) Finding the solution # If the sum is too big, then make \\(b\\) smaller. If it is too large, make \\(a\\) larger. Stop when \\(a\u0026gt;b\\).\nOptimising sum calculation # \\((a+1)^2 = a^2+2a+1\\)\n\\((b-1)^2 = b^2-2b+1\\)\nWe can use this to update sum:\n\\((a+1)^2+b^2 = a^2+2a+1+b^2\\)\n\\( \\quad \\quad \\quad \\quad \\quad \\ \\ \\ = \\text{sum} + 2a + 1\\)\nTherefore, instead of recalculating the sum each time using a*a+b*b, we can instead use these formulae. For example, if increasing a, sum += 2a+1.\nComplexity # Time complexity: O(\\(\\sqrt{n}\\) )\nSpace complexity: O(1)\nCode # bool judgeSquareSum(const int\u0026amp; c) { // let a\u0026lt;=b unsigned int a = 0; unsigned int b = ceil(sqrt(c)); unsigned int sum = b*b; while(a\u0026lt;=b){ if(sum==c){ return true; } else if(sum\u0026lt;c){ // increase a // (a+1)^2 = a^2 +2a+1 sum += 2*a+1; a++; } else{ // decrease b // (b-1)^2 = b^2-2b+1 sum += 1-2*b; b--; } } return false; } ","date":"17 June 2024","externalUrl":null,"permalink":"/problems/leetcode_633/","section":"Problems","summary":"Problem Description # Check out the problem on Leetcode","title":"Leetcode 633: Sum of Square Numbers","type":"problems"},{"content":" Problem Description # Check out the problem on Leetcode\nYou have a string representing the attendance record of a student:\nA = Absent L = Late P = Present You must find the number of strings of length n that have the following properties:\nonly contain the letters (A,L,P) contain less than two A\u0026rsquo;s don\u0026rsquo;t contain any occurences of \u0026lsquo;LLL\u0026rsquo; Solution # My approach will be to use recurrence relations to calculate the number of combinations whilst avoiding considering the actual possible strings.\nCreating a recurrence (ignoring absences) # Let \\(S_n\\) be a valid string with no absences. Let \\(F(n)\\) be the number of such strings. We can make a valid string \\(S_n\\) using shorter ones:\n\\(S_{n-1}\\) + P \\(S_{n-2}\\) + PL \\(S_{n-3}\\) + PLL We can get all possible strings (longer than 3) this way with no double counting. For example, PLLPPL = PLL + P + PL.\nTherefore: \\(F(n)=F(n-1)+F(n-2)+F(n-3)\\)\nAccounting for absences # We are allowed to have a maximum of one absence.\nIf the absence is after lesson \\(i\\), then we have a no-absence string of length \\(i\\) before it and a no-absence string of length \\(n-i-1\\) after it. For example, if we have 10 lessons and the student is absent for lesson 3:\n$$ \\text{string} = S_2 + A + S_7 $$\nTherefore, the number of valid strings for a given absence = \\(F(i) * F(n-i-1)\\)\nWe can find the total number of valid strings by iterating over all possible lessons up to \\(i=n/2\\) and then multiply by two because \\(F(2)*F(7) = F(7)*F(2)\\).\nFinally, we add \\(F(n)\\) to the total, for the situation where the student has no absences.\nComplexity # Time complexity: O(n) Space complexity: O(n) Code # int checkRecord(const int\u0026amp; n) { // check for base case if(n==1){ return 3; } else if(n==2){ return 8; } // F[n] = number of ways to form a string of length n with no absences vector\u0026lt;long long\u0026gt; F(n+1, 0ll); F[0]=1; F[1]=2; F[2]=4; const long long MOD = 1000000007; for(int i=3; i\u0026lt;=n; i++){ F[i] = (F[i-3]+F[i-2]+F[i-1]) % MOD; } long long numWithAbsences = 0; for(int i=0; i\u0026lt;n/2; i++){ numWithAbsences += (F[i]*F[n-i-1]) % MOD; } numWithAbsences *= 2; if(n % 2 == 1){ numWithAbsences += F[n/2]*F[n/2]; } return (F[n] + numWithAbsences) % MOD; } ","date":"26 May 2024","externalUrl":null,"permalink":"/problems/leetcode_552/","section":"Problems","summary":"Problem Description # Check out the problem on Leetcode","title":"Leetcode 552: Student Attendance Record II","type":"problems"},{"content":"","date":"26 May 2024","externalUrl":null,"permalink":"/tags/recurrence-relation/","section":"Tags","summary":"","title":"Recurrence Relation","type":"tags"},{"content":" Problem Description # Check out the full problem description\nThere are two types of persons:\nThe good person: The person who always tells the truth. The bad person: The person who might tell the truth and might lie. You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following:\n0 which represents a statement made by person i that person j is a bad person. 1 which represents a statement made by person i that person j is a good person. 2 represents that no statement is made by person i about person j. Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 \u0026lt;= i \u0026lt; n.\nReturn the maximum number of people who can be good based on the statements made by the n people.\nSolution # The general approach I will take is to iterate over each possible configuration of good and bad people using bit manipulation.\nRepresenting a configuration # Represent a possible configuration of n people using n bits.\n1 = good person 0 = bad person E.g. 1010 = People 1,3 are good. People 2,4 are bad. Iterating over configurations # Naive approach # We can iterate over all the possible configurations, starting with all people lying, like so:\nfor(int config=0; config\u0026lt;(1\u0026lt;\u0026lt;n); config++){ // check if the solution is valid } Improved approach # We first start by looking at configurations where everyone is good. We then stop looking when none of the remaining possible solutions can beat our current one.\nFor example, imagine we have five people, and found a configuration where 3 could be telling the truth (maxGood is 3), we need to find at least four 1\u0026rsquo;s (truthful bits) to find a better solution. In this example, if config\u0026lt;01111, then we can stop because config is decreasing, so it will never have four 1\u0026rsquo;s.\ninitialise config = 111...1111 stop searching when config \u0026lt; ..000111.. (ending in maxGood 1\u0026rsquo;s) for(int config=(1\u0026lt;\u0026lt;n)-1; config \u0026gt;= (1\u0026lt;\u0026lt;(maxGood+1))-1; config--){ // check if the solution is valid } Checking if a solution is valid # A solution is invalid when someone who is assumed to be truthful tells a lie. (Ignore what the liars say.)\nTherefore, iterate over all the truthful people in a solution and check what they say matches our proposed solution.\nbool configurationWorks = true; // iterate over each person in the config for(int j=0; j\u0026lt;n \u0026amp;\u0026amp; configurationWorks; j++){ if((config\u0026gt;\u0026gt;j)\u0026amp;1){ // the current person is telling the truth for(int h=0; h\u0026lt;n; h++){ // the accused is not what they are supposed to be // e.g. person j says person h is good when they are bad if(statements[j][h] != 2 \u0026amp;\u0026amp; statements[j][h] != ((config\u0026gt;\u0026gt;h)\u0026amp;1)){ configurationWorks = false; break; } } } } Setting the new Max Score # The number of good people in a configuration is the number of 1\u0026rsquo;s in the binary representation of config. There is already a function to do this called __builtin_popcount.\nif(configurationWorks){ maxGood = max(maxGood, __builtin_popcount(config)); } Complexity # Time complexity: O(\\(N^2 * 2^N\\))\nSpace complexity: O(\\(\\sqrt{N}\\))\nCode # class Solution { public: int maximumGood(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; statements) { int n = statements.size(); int maxGood = 0; // config has n bits. A 1 represents good, and a 0 represents bad for(int config=(1\u0026lt;\u0026lt;n)-1; config \u0026gt;= (1\u0026lt;\u0026lt;(maxGood+1))-1; config--){ bool configurationWorks = true; // iterate over each person in the config for(int j=0; j\u0026lt;n \u0026amp;\u0026amp; configurationWorks; j++){ if((config\u0026gt;\u0026gt;j)\u0026amp;1){ // the current person is telling the truth for(int h=0; h\u0026lt;n; h++){ // the accused is not what they are supposed to be // e.g. person j says person h is good when they are bad if(statements[j][h] != 2 \u0026amp;\u0026amp; statements[j][h] != ((config\u0026gt;\u0026gt;h)\u0026amp;1)){ configurationWorks = false; break; } } } } if(configurationWorks){ maxGood = max(maxGood, __builtin_popcount(config)); } } return maxGood; } }; ","date":"24 May 2024","externalUrl":null,"permalink":"/problems/leetcode_2151/","section":"Problems","summary":"Problem Description # Check out the full problem description","title":"Leetcode 2151: Maximum Good People Based on Statements","type":"problems"},{"content":" Problem Description # The Problem:\nGiven an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.\nExample:\nInput: nums = [-1, 10, 6, 7, -7, 1] Output: 7 Explanation: Both 1 and 7 have their corresponding negative numbers in the array. 7 is the largest. Solution Approach # General Approach # Pass over the array, storing the fact we have seen that item. If the number\u0026rsquo;s negative has been seen before, then update the new maximum value.\nOptimisations # The constraints only allow a small range of possible values:\n\\( -1000 \u0026lt;= \\text{nums[i]} \u0026lt;= 1000\\)\nTherefore, we can use a static data structure, like an array, and store for every possible number whether we have seen it.\nSince we only need to store true/false for each number to represent whether it has been seen before, we can use a bitset for space efficiency.\nGiven the smallest possible value is -1000, this will be index 0, and so to get the index of a number you add 1000.\nExample # we see the number 47 seen[1000-47]==1 is checked and found false so seen[1047] is set to 1 Later, the number -47 is seen. seen[1000 -(-47)]==1 is checked and found true |-47| is compared to the current maximum number Complexity # Time complexity: O(n)\nSpace complexity: O(n)\nCode # class Solution { public: int findMaxK(const vector\u0026lt;int\u0026gt;\u0026amp; nums) { // indexes 1001-2000 represent positives. 0-999 are negatives bitset\u0026lt;2001\u0026gt; nums_bitset; int ans = -1; for(const int\u0026amp; num : nums){ if(nums_bitset[1000-num]==1){ ans = max(ans, abs(num)); } else{ nums_bitset[1000+num] = 1; } } return ans; } }; ","date":"2 May 2024","externalUrl":null,"permalink":"/problems/leetcode_2441/","section":"Problems","summary":"Problem Description # The Problem:","title":"Leetcode 2441. Largest Positive Integer That Exists With Its Negative","type":"problems"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]