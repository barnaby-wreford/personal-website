[{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/categories/leetcode/","section":"Categories","summary":"","title":"Leetcode","type":"categories"},{"content":" Problem Description # Check out the problem on Leetcode\nGiven a non-negative integer \\(c\\), decide whether there exists two integers \\(a\\) and \\(b\\) such that \\(a^2+b^2=c\\)\nSolution # Try different combinations of \\((a,b)\\), adjusting the guess each time based on whether their sum is too large or too small. I define \\(a\\) as the smaller value and \\(b\\) as the larger value.\nInitial values # \\(a=0\\) \\(b^2\u0026gt;=c\\) \\(\\text{sum}=b^2\\) Finding the solution # If the sum is too big, then make \\(b\\) smaller. If it is too large, make \\(a\\) larger. Stop when \\(a\u0026gt;b\\).\nOptimising sum calculation # \\((a+1)^2 = a^2+2a+1\\)\n\\((b-1)^2 = b^2-2b+1\\)\nWe can use this to update sum:\n\\((a+1)^2+b^2 = a^2+2a+1+b^2\\)\n\\( \\quad \\quad \\quad \\quad \\quad \\ \\ \\ = \\text{sum} + 2a + 1\\)\nTherefore, instead of recalculating the sum each time using a*a+b*b, we can instead use these formulae. For example, if increasing a, sum += 2a+1.\nComplexity # Time complexity: O(\\(\\sqrt{n}\\) )\nSpace complexity: O(1)\nCode # bool judgeSquareSum(const int\u0026amp; c) { // let a\u0026lt;=b unsigned int a = 0; unsigned int b = ceil(sqrt(c)); unsigned int sum = b*b; while(a\u0026lt;=b){ if(sum==c){ return true; } else if(sum\u0026lt;c){ // increase a // (a+1)^2 = a^2 +2a+1 sum += 2*a+1; a++; } else{ // decrease b // (b-1)^2 = b^2-2b+1 sum += 1-2*b; b--; } } return false; } ","date":"17 June 2024","externalUrl":null,"permalink":"/problems/leetcode_633/","section":"Problems","summary":"Problem Description # Check out the problem on Leetcode","title":"Leetcode 633: Sum of Square Numbers","type":"problems"},{"content":"I\u0026rsquo;m a Computer Science student with a passion for everything quantitative. This site chronicals my interests, particularly problems and projects I\u0026rsquo;m working on.\nIf you have any questions about a post, ideas for what I should look at next, or just want to get to know me better, please get in touch!\n","date":"17 June 2024","externalUrl":null,"permalink":"/","section":"My Homepage","summary":"I\u0026rsquo;m a Computer Science student with a passion for everything quantitative.","title":"My Homepage","type":"page"},{"content":"This section contains all my articles on Maths and Algorithms problems.\n","date":"17 June 2024","externalUrl":null,"permalink":"/problems/","section":"Problems","summary":"This section contains all my articles on Maths and Algorithms problems.","title":"Problems","type":"problems"},{"content":" Problem Description # Check out the problem on Leetcode\nYou have a string representing the attendance record of a student:\nA = Absent L = Late P = Present You must find the number of strings of length n that have the following properties:\nonly contain the letters (A,L,P) contain less than two A\u0026rsquo;s don\u0026rsquo;t contain any occurences of \u0026lsquo;LLL\u0026rsquo; Solution # My approach will be to use recurrence relations to calculate the number of combinations whilst avoiding considering the actual possible strings.\nCreating a recurrence (ignoring absences) # Let \\(S_n\\) be a valid string with no absences. Let \\(F(n)\\) be the number of such strings. We can make a valid string \\(S_n\\) using shorter ones:\n\\(S_{n-1}\\) + P \\(S_{n-2}\\) + PL \\(S_{n-3}\\) + PLL We can get all possible strings (longer than 3) this way with no double counting. For example, PLLPPL = PLL + P + PL.\nTherefore: \\(F(n)=F(n-1)+F(n-2)+F(n-3)\\)\nAccounting for absences # We are allowed to have a maximum of one absence.\nIf the absence is after lesson \\(i\\), then we have a no-absence string of length \\(i\\) before it and a no-absence string of length \\(n-i-1\\) after it. For example, if we have 10 lessons and the student is absent for lesson 3:\n$$ \\text{string} = S_2 + A + S_7 $$\nTherefore, the number of valid strings for a given absence = \\(F(i) * F(n-i-1)\\)\nWe can find the total number of valid strings by iterating over all possible lessons up to \\(i=n/2\\) and then multiply by two because \\(F(2)*F(7) = F(7)*F(2)\\).\nFinally, we add \\(F(n)\\) to the total, for the situation where the student has no absences.\nComplexity # Time complexity: O(n) Space complexity: O(n) Code # int checkRecord(const int\u0026amp; n) { // check for base case if(n==1){ return 3; } else if(n==2){ return 8; } // F[n] = number of ways to form a string of length n with no absences vector\u0026lt;long long\u0026gt; F(n+1, 0ll); F[0]=1; F[1]=2; F[2]=4; const long long MOD = 1000000007; for(int i=3; i\u0026lt;=n; i++){ F[i] = (F[i-3]+F[i-2]+F[i-1]) % MOD; } long long numWithAbsences = 0; for(int i=0; i\u0026lt;n/2; i++){ numWithAbsences += (F[i]*F[n-i-1]) % MOD; } numWithAbsences *= 2; if(n % 2 == 1){ numWithAbsences += F[n/2]*F[n/2]; } return (F[n] + numWithAbsences) % MOD; } ","date":"26 May 2024","externalUrl":null,"permalink":"/problems/leetcode_552/","section":"Problems","summary":"Problem Description # Check out the problem on Leetcode","title":"Leetcode 552: Student Attendance Record II","type":"problems"},{"content":"","date":"26 May 2024","externalUrl":null,"permalink":"/tags/recurrence-relation/","section":"Tags","summary":"","title":"Recurrence Relation","type":"tags"},{"content":"","date":"26 May 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Problem Description # Check out the full problem description\nThere are two types of persons:\nThe good person: The person who always tells the truth. The bad person: The person who might tell the truth and might lie. You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following:\n0 which represents a statement made by person i that person j is a bad person. 1 which represents a statement made by person i that person j is a good person. 2 represents that no statement is made by person i about person j. Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 \u0026lt;= i \u0026lt; n.\nReturn the maximum number of people who can be good based on the statements made by the n people.\nSolution # The general approach I will take is to iterate over each possible configuration of good and bad people using bit manipulation.\nRepresenting a configuration # Represent a possible configuration of n people using n bits.\n1 = good person 0 = bad person E.g. 1010 = People 1,3 are good. People 2,4 are bad. Iterating over configurations # Naive approach # We can iterate over all the possible configurations, starting with all people lying, like so:\nfor(int config=0; config\u0026lt;(1\u0026lt;\u0026lt;n); config++){ // check if the solution is valid } Improved approach # We first start by looking at configurations where everyone is good. We then stop looking when none of the remaining possible solutions can beat our current one.\nFor example, imagine we have five people, and found a configuration where 3 could be telling the truth (maxGood is 3), we need to find at least four 1\u0026rsquo;s (truthful bits) to find a better solution. In this example, if config\u0026lt;01111, then we can stop because config is decreasing, so it will never have four 1\u0026rsquo;s.\ninitialise config = 111...1111 stop searching when config \u0026lt; ..000111.. (ending in maxGood 1\u0026rsquo;s) for(int config=(1\u0026lt;\u0026lt;n)-1; config \u0026gt;= (1\u0026lt;\u0026lt;(maxGood+1))-1; config--){ // check if the solution is valid } Checking if a solution is valid # A solution is invalid when someone who is assumed to be truthful tells a lie. (Ignore what the liars say.)\nTherefore, iterate over all the truthful people in a solution and check what they say matches our proposed solution.\nbool configurationWorks = true; // iterate over each person in the config for(int j=0; j\u0026lt;n \u0026amp;\u0026amp; configurationWorks; j++){ if((config\u0026gt;\u0026gt;j)\u0026amp;1){ // the current person is telling the truth for(int h=0; h\u0026lt;n; h++){ // the accused is not what they are supposed to be // e.g. person j says person h is good when they are bad if(statements[j][h] != 2 \u0026amp;\u0026amp; statements[j][h] != ((config\u0026gt;\u0026gt;h)\u0026amp;1)){ configurationWorks = false; break; } } } } Setting the new Max Score # The number of good people in a configuration is the number of 1\u0026rsquo;s in the binary representation of config. There is already a function to do this called __builtin_popcount.\nif(configurationWorks){ maxGood = max(maxGood, __builtin_popcount(config)); } Complexity # Time complexity: O(N^2 * 2^N)\nSpace complexity: O(sqrt(N))\nCode # class Solution { public: int maximumGood(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; statements) { int n = statements.size(); int maxGood = 0; // config has n bits. A 1 represents good, and a 0 represents bad for(int config=(1\u0026lt;\u0026lt;n)-1; config \u0026gt;= (1\u0026lt;\u0026lt;(maxGood+1))-1; config--){ bool configurationWorks = true; // iterate over each person in the config for(int j=0; j\u0026lt;n \u0026amp;\u0026amp; configurationWorks; j++){ if((config\u0026gt;\u0026gt;j)\u0026amp;1){ // the current person is telling the truth for(int h=0; h\u0026lt;n; h++){ // the accused is not what they are supposed to be // e.g. person j says person h is good when they are bad if(statements[j][h] != 2 \u0026amp;\u0026amp; statements[j][h] != ((config\u0026gt;\u0026gt;h)\u0026amp;1)){ configurationWorks = false; break; } } } } if(configurationWorks){ maxGood = max(maxGood, __builtin_popcount(config)); } } return maxGood; } }; ","date":"24 May 2024","externalUrl":null,"permalink":"/problems/leetcode_2151/","section":"Problems","summary":"Problem Description # Check out the full problem description","title":"Leetcode 2151: Maximum Good People Based on Statements","type":"problems"},{"content":" Problem Description # The Problem:\nGiven an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.\nExample:\nInput: nums = [-1, 10, 6, 7, -7, 1] Output: 7 Explanation: Both 1 and 7 have their corresponding negative numbers in the array. 7 is the largest. Solution Approach # General Approach # Pass over the array, storing the fact we have seen that item. If the number\u0026rsquo;s negative has been seen before, then update the new maximum value.\nOptimisations # The constraints only allow a small range of possible values:\n\\( -1000 \u0026lt;= \\text{nums[i]} \u0026lt;= 1000\\)\nTherefore, we can use a static data structure, like an array, and store for every possible number whether we have seen it.\nSince we only need to store true/false for each number to represent whether it has been seen before, we can use a bitset for space efficiency.\nGiven the smallest possible value is -1000, this will be index 0, and so to get the index of a number you add 1000.\nExample # we see the number 47 seen[1000-47]==1 is checked and found false so seen[1047] is set to 1 Later, the number -47 is seen. seen[1000 -(-47)]==1 is checked and found true |-47| is compared to the current maximum number Complexity # Time complexity: O(n)\nSpace complexity: O(n)\nCode # class Solution { public: int findMaxK(const vector\u0026lt;int\u0026gt;\u0026amp; nums) { // indexes 1001-2000 represent positives. 0-999 are negatives bitset\u0026lt;2001\u0026gt; nums_bitset; int ans = -1; for(const int\u0026amp; num : nums){ if(nums_bitset[1000-num]==1){ ans = max(ans, abs(num)); } else{ nums_bitset[1000+num] = 1; } } return ans; } }; ","date":"2 May 2024","externalUrl":null,"permalink":"/problems/leetcode_2441/","section":"Problems","summary":"Problem Description # The Problem:","title":"Leetcode 2441. Largest Positive Integer That Exists With Its Negative","type":"problems"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]